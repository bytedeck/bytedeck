from datetime import timedelta

from django.contrib.auth import get_user_model
from django.db import connection
from django.utils import timezone

from django_celery_beat.models import PeriodicTask
from django_tenants.test.cases import TenantTestCase
from django_tenants.utils import get_public_schema_name, schema_context
from model_bakery import baker

from announcements import tasks
from announcements.models import Announcement
from announcements.tasks import get_users_to_email
from courses.models import Course, CourseStudent
from siteconfig.models import SiteConfig

User = get_user_model()


class AnnouncementTasksTests(TenantTestCase):
    """ Run tasks asyncronously with apply() """

    def setUp(self):
        self.announcement = baker.make(Announcement)

        # need a teacher before students can be created or the profile creation will fail when trying to notify
        self.test_teacher = User.objects.create_user('test_teacher', is_staff=True)
        self.test_student1 = User.objects.create_user('test_student')
        self.test_student2 = baker.make(User)

        self.ai_user, _ = User.objects.get_or_create(
            pk=SiteConfig.get().deck_ai.pk,
            defaults={
                'username': "Autogenerated AI",
            },
        )

    def test_get_users_to_email(self):
        """Should return correct list of users to email"""

        course = baker.make(Course)
        semester = SiteConfig.get().active_semester

        # Student with empty email but wants to receive announcements
        user_empty_email = baker.make(User, email='')
        user_empty_email.profile.get_announcements_by_email = True
        user_empty_email.profile.save()
        baker.make(CourseStudent, user=user_empty_email, course=course, semester=semester)

        # Teacher with empty email but wants to receive announcements
        teacher_empty_email = baker.make(User, email='', is_staff=True)
        teacher_empty_email.profile.get_announcements_by_email = True
        teacher_empty_email.profile.save()

        # Student with an email but does not want to receive announcement emails
        student_no_announcement_emails = baker.make(User, email='student_email@bytedeck.com')
        baker.make(CourseStudent, user=student_no_announcement_emails, course=course, semester=semester)

        # Teacher with an email but does not want to receive announcement emails
        baker.make(User, email='teacher_email@bytedeck.com', is_staff=True)

        # Inactive student with email and announcements enabled
        inactive_student = baker.make(User, email='student_inactive@bytedeck.com')
        inactive_student.profile.get_announcements_by_email = True
        inactive_student.profile.save()
        baker.make(CourseStudent, user=inactive_student, course=None, semester=None)

        for i in range(11):
            is_staff = i % 2 == 0
            email = f'{i}@bytedeck.com'
            user = baker.make(User, email=email, is_staff=is_staff)
            user.profile.get_announcements_by_email = True
            user.profile.save()

            if not is_staff:
                baker.make(CourseStudent,
                           user=user,
                           course=course,
                           semester=semester)
        emails = get_users_to_email()
        self.assertEqual(len(emails), 12)  # 11 + deck owner = 12

    def test_send_announcement_emails(self):

        task_result = tasks.send_announcement_emails.apply(
            kwargs={
                "content": "",
                "root_url": "https://example.com",
                "absolute_url": "/link/to/announcement/"
            }
        )
        self.assertTrue(task_result.successful())

    def test_publish_announcement(self):
        self.assertTrue(self.announcement.draft)
        task_result = tasks.publish_announcement.apply(
            kwargs={
                'user_id': self.test_teacher.id,
                'announcement_id': self.announcement.id,
                'root_url': "https://example.com"
            }
        )
        self.assertTrue(task_result.successful())

        # Make sure the announcement is no longer a draft and not gonna auto_publish
        # get updated instance of announcement
        no_longer_draft_announcement = Announcement.objects.get(pk=self.announcement.pk)
        self.assertFalse(no_longer_draft_announcement.draft)
        self.assertFalse(no_longer_draft_announcement.auto_publish)

        task_name = f"Autopublish task for Announcement #{no_longer_draft_announcement.id} on schema {connection.schema_name}"
        with self.assertRaises(PeriodicTask.DoesNotExist):
            PeriodicTask.objects.get(name=task_name)

        with self.assertRaises(PeriodicTask.DoesNotExist):
            with schema_context(get_public_schema_name()):
                PeriodicTask.objects.get(name=task_name)

    def test_publish_announcement_past_date(self):
        past_announcement = baker.make(Announcement,
                                       datetime_released=timezone.now() - timedelta(days=90))
        self.assertTrue(past_announcement.draft)
        self.assertFalse(past_announcement.auto_publish)

        task_result = tasks.publish_announcement.apply(
            kwargs={
                'user_id': self.test_teacher.id,
                'announcement_id': past_announcement.id,
                'root_url': 'https://example.com'
            }
        )

        self.assertTrue(task_result.successful())
        past_announcement.refresh_from_db()
        self.assertFalse(past_announcement.draft)

    def test_send_notifications(self):

        tasks.send_notifications(self.ai_user.id, self.announcement.id)

        # run method as synchronous task
        task_result = tasks.send_notifications.apply(
            kwargs={
                'user_id': self.ai_user.id,  # self.test_teacher.id,
                'announcement_id': self.announcement.id
            })
        self.assertTrue(task_result.successful())
